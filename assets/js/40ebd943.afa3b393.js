"use strict";(self.webpackChunktarant_page=self.webpackChunktarant_page||[]).push([[104],{3905:(e,t,a)=>{a.d(t,{Zo:()=>h,kt:()=>m});var n=a(7294);function o(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function r(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function i(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?r(Object(a),!0).forEach((function(t){o(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):r(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function s(e,t){if(null==e)return{};var a,n,o=function(e,t){if(null==e)return{};var a,n,o={},r=Object.keys(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||(o[a]=e[a]);return o}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(o[a]=e[a])}return o}var l=n.createContext({}),c=function(e){var t=n.useContext(l),a=t;return e&&(a="function"==typeof e?e(t):i(i({},t),e)),a},h=function(e){var t=c(e.components);return n.createElement(l.Provider,{value:t},e.children)},p="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},u=n.forwardRef((function(e,t){var a=e.components,o=e.mdxType,r=e.originalType,l=e.parentName,h=s(e,["components","mdxType","originalType","parentName"]),p=c(a),u=o,m=p["".concat(l,".").concat(u)]||p[u]||d[u]||r;return a?n.createElement(m,i(i({ref:t},h),{},{components:a})):n.createElement(m,i({ref:t},h))}));function m(e,t){var a=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var r=a.length,i=new Array(r);i[0]=u;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[p]="string"==typeof e?e:o,i[1]=s;for(var c=2;c<r;c++)i[c]=a[c];return n.createElement.apply(null,i)}return n.createElement.apply(null,a)}u.displayName="MDXCreateElement"},1081:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>d,frontMatter:()=>r,metadata:()=>s,toc:()=>c});var n=a(7462),o=(a(7294),a(3905));const r={sidebar_position:1},i="Thinking in Tarant",s={unversionedId:"Quick Start/thinking-in-tarant",id:"Quick Start/thinking-in-tarant",title:"Thinking in Tarant",description:"Tarant is a framework which has been designed for performance and easiness of development. However, it's based in the actor model, so some known design patterns",source:"@site/docs/Quick Start/thinking-in-tarant.md",sourceDirName:"Quick Start",slug:"/Quick Start/thinking-in-tarant",permalink:"/docs/Quick Start/thinking-in-tarant",draft:!1,editUrl:"https://github.com/tarantx/tarant-page/tree/main/docs/Quick Start/thinking-in-tarant.md",tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1},sidebar:"tutorialSidebar",previous:{title:"Quick Start",permalink:"/docs/category/quick-start"},next:{title:"Tutorial: A Chat Application",permalink:"/docs/Quick Start/a-simple-application"}},l={},c=[{value:"Before we start",id:"before-we-start",level:2},{value:"What are actors?",id:"what-are-actors",level:2}],h={toc:c},p="wrapper";function d(e){let{components:t,...r}=e;return(0,o.kt)(p,(0,n.Z)({},h,r,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"thinking-in-tarant"},"Thinking in Tarant"),(0,o.kt)("p",null,"Tarant is a framework which has been designed for performance and easiness of development. However, it's based in the actor model, so some known design patterns\nchange and there are alternatives that simplify the development of applications. In this tutorial, we will walkthrough over the design principles when working with\nactors and tarant."),(0,o.kt)("h2",{id:"before-we-start"},"Before we start"),(0,o.kt)("p",null,"This tutorial assumes that you have basic knowledge on how TypeScript or JavaScript classes work. You don't need really extensive knowledge on the internals\nof a class, but understanding how to create one is a must. "),(0,o.kt)("p",null,"If you don't feel comfortable working with classes, we recommend to read the following tutorials first:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Objects"},"Introducing JavaScript Objects (MDN)")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Objects/Classes_in_JavaScript"},"Classes in JavaScript (MDN)")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes"},"Classes Reference (MDN)"))),(0,o.kt)("h2",{id:"what-are-actors"},"What are actors?"),(0,o.kt)("p",null,"First, let's start with the building blocks of tarant. A good understanding of what actors are is important to design an application with all the advantages of\nthe actor model."),(0,o.kt)("p",null,"An actor ",(0,o.kt)("strong",{parentName:"p"},"is an object"),", in the broader sense of the concept. An actor, as objects, contain both data and behaviour. However, what makes an actor different from\nordinary JavaScript objects? "),(0,o.kt)("p",null,"JavaScript objects are passive data structures: they only behave when a method is called on the object. Usually you will call an object method when your\napplication is reacting to some user input."),(0,o.kt)("p",null,(0,o.kt)("img",{alt:"A method on an object is called when a button is clicked",src:a(4808).Z,width:"867",height:"362"})),(0,o.kt)("p",null,"An actor is ",(0,o.kt)("strong",{parentName:"p"},"an active object"),". Actors are there, interacting between each other, without any need of orchestration. An actor can just send messages",(0,o.kt)("sup",{parentName:"p",id:"fnref-1"},(0,o.kt)("a",{parentName:"sup",href:"#fn-1",className:"footnote-ref"},"1"))," to other\nactors. Also, actors can just behave without any stimulae, just running their own business logic, like for example, scheduled work."),(0,o.kt)("p",null,"But there are other differences too. For example, when you call a method on an object, you execute ",(0,o.kt)("em",{parentName:"p"},"a direct call")," to the object. The owner of the resources is the\ncaller of the object, not the object itself. If you have multiple threads running concurrently on the same object, you can have ",(0,o.kt)("em",{parentName:"p"},"race conditions"),", which means,\nmodifying data concurrently (and likely corrupting it!). To avoid this to happen, objects need to implement different locking mechanisms that make reasoning about\nthe code pretty difficult."),(0,o.kt)("p",null,"But wait, we are in JavaScript. ",(0,o.kt)("strong",{parentName:"p"},"JavaScript is single-threaded"),", we can not have race conditions! That is ",(0,o.kt)("em",{parentName:"p"},"mostly")," true, however, with async code things get\ncomplex really quickly. Consider the following code in JavaScript:"),(0,o.kt)("iframe",{src:"https://codesandbox.io/embed/race-condition-js-2veo5l?fontsize=14&hidenavigation=1&theme=dark",style:{width:"100%",height:"500px",border:"0",borderRadius:"4px",overflow:"hidden"},title:"race-condition-js",allow:"accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking",sandbox:"allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"}),(0,o.kt)("p",null,"What is the result of counter at the end of the application? The answer is ",(0,o.kt)("em",{parentName:"p"},"it depends"),". "),(0,o.kt)("p",null,"I ran the code a few times, sometimes the number was 12, 8, sometimes 10, and sometimes 6. Why?"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Sometimes the order is as follows:",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"addOne, addOne, multiplyByTwo, multiplyByTwo => 12"),(0,o.kt)("li",{parentName:"ul"},"multiplyByTwo, addOne, addOne, multiplyByTwo => 8"),(0,o.kt)("li",{parentName:"ul"},"addOne, multiplyByTwo, addOne, multiplyByTwo => 10")))),(0,o.kt)("p",null,"Even if we schedule the functions in order, because we are doing asynchronous code, the order of execution is not guaranteed!\nSo even in a single-threaded world, we can have race conditions! This is one of the most complex problems in lots of web applications\nthat require multiple calls to multiple backends."),(0,o.kt)("p",null,(0,o.kt)("img",{alt:"A race condition just happened",src:a(499).Z,width:"1528",height:"362"})),(0,o.kt)("p",null,"However, for consistency, what would be the correct state? Actors ensure that any operations, independently of how much time they take, they are executed in order. An\nactor ",(0,o.kt)("strong",{parentName:"p"},"would ensure that the result is always 10")," by design. This is the same code within an actor:"),(0,o.kt)("iframe",{src:"https://codesandbox.io/embed/tarant-no-race-condition-rhu4bs?fontsize=14&hidenavigation=1&theme=dark",style:{width:"100%",height:"500px",border:"0",borderRadius:"4px",overflow:"hidden"},title:"tarant-no-race-condition",allow:"accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking",sandbox:"allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"}),"As you can see, an actor contains both the data and the behaviour like an ordinary class. And the code itself, is really similar. There are only two changes in the code that are important:",(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Actors extend the ",(0,o.kt)("inlineCode",{parentName:"li"},"Actor")," class from tarant."),(0,o.kt)("li",{parentName:"ul"},"Actors must be instantiated through the actor system",(0,o.kt)("sup",{parentName:"li",id:"fnref-2"},(0,o.kt)("a",{parentName:"sup",href:"#fn-2",className:"footnote-ref"},"2")),".")),(0,o.kt)("p",null,"But if they are like classes, how they ensure the correctness of the code? Actors are a little bit more complex than classes internally, but tarant encapsulates\nall that."),(0,o.kt)("p",null,"When you call a method in an actor, you send a message to it's mailbox. A mailbox is the list of operations that has to be done by the actor. The actor will be\npolling all messages in the mailbox, one by one, and in order of insertion. The actor guarantees that only processes one message at a time. A simple diagram of\nhow it works can help you visualise how everything works altogether:"),(0,o.kt)("p",null,(0,o.kt)("img",{alt:"Messages between actors",src:a(705).Z,width:"1452",height:"155"})),(0,o.kt)("p",null,"However, as mentioned, all this complexity is hidden in the framework. You can still call your methods and wait for results, as you would do in ordinary\nJavaScript classes! This enables different patterns that we will explain later in the tutorial."),(0,o.kt)("p",null,"But wait, there are more differences between actors and objects. One of them is what we call ",(0,o.kt)("strong",{parentName:"p"},"the lifecycle"),"."),(0,o.kt)("p",null,"Objects are ref-counted. It means that they only live during a transaction and are freed when no other object has a reference to them. Let's think in the following\nscenario:"),(0,o.kt)("p",null,(0,o.kt)("img",{alt:"Object Lifecycle",src:a(9634).Z,width:"1061",height:"797"})),(0,o.kt)("p",null,"In the previous figure, the red area is the ",(0,o.kt)("strong",{parentName:"p"},"lifecycle")," of an object. In this case, the object is created in the repository, when we ask our database to retrieve\nthe latest state of the counter. Then, our CounterService (or any other orchestrator), will call a method on the object, update the state, and save it again in our\ndatabase. When the object is stored in the database, we return a copy of the object (for example, for serialization) and the copy is lost. The garbage collector will\neventually clean up the object."),(0,o.kt)("p",null,"However, the counter object still exists ",(0,o.kt)("em",{parentName:"p"},"in theory"),". In our business, the ",(0,o.kt)("em",{parentName:"p"},"counter")," exists, we can just mutate it whenever we want, and get the state. What we created\nduring our transaction is ",(0,o.kt)("inlineCode",{parentName:"p"},"a representation of the counter")," that lasts until the request is done. So every time we want to modify the counter, we have to create an\nobject, mutate it, and store it in the database."),(0,o.kt)("p",null,"An actor, but, is different. Actor is designed to share the same lifecycle of the business object it represents. The counter lives for an hour? Then the actor also.\nThe counter can live for a few years? Then so be it, the actor will also live for the same amount of time."),(0,o.kt)("p",null,"The same flow in tarant, would look like:"),(0,o.kt)("p",null,(0,o.kt)("img",{alt:"Object Lifecycle",src:a(8828).Z,width:"896",height:"281"})),(0,o.kt)("p",null,"But, the question that you might have now is: what happens when I have billions of counters? An application might get out of memory easily. However, tarant can\n",(0,o.kt)("strong",{parentName:"p"},"evict")," actors, which means, releasing the memory used by the actor when the actor has been idle for a while. When the actor is used, tarant can ",(0,o.kt)("strong",{parentName:"p"},"materialise"),"\nthe actor again so it can be used."),(0,o.kt)("p",null,"Using more persistent memory has important benefits, avoiding fragmentation and improving cacheability. However, this is taken already by tarant, you can just use it.\nWhen designing an application, just think as your business objects as actors, and that's it. This reasoning is pretty complex at the beginning, but the brain gets used\nto it."),(0,o.kt)("p",null,"So, to summarise:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"An actor is similar to an object"),": An actor holds both data and behaviour in one place."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"An actor is active"),": Does not require external stimulus to do business logic."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"An actor is concurrency-safe"),": You can just send the actor messages from anywhere safely without thinking on race conditions."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"An actor is message driven"),": An actor does not care where a message is coming from, just that it ends in it's mailbox."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"An actor lifecycle is long"),": From seconds, to hours, to days, to months, to years.")),(0,o.kt)("hr",null),(0,o.kt)("p",null,(0,o.kt)("sup",{parentName:"p",id:"fnref-1"},(0,o.kt)("a",{parentName:"sup",href:"#fn-1",className:"footnote-ref"},"1"))," A message is how we call method calls to actors."),(0,o.kt)("p",null,(0,o.kt)("sup",{parentName:"p",id:"fnref-2"},(0,o.kt)("a",{parentName:"sup",href:"#fn-2",className:"footnote-ref"},"2"))," An Actor System is where all the actors live. We will dive later in the concept."))}d.isMDXComponent=!0},4808:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/0-object-method-on-event-ef2aad827cf88ad43724e124ed5a40b0.png"},499:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/1-race-conditions-0481228208f7e4e8fb05acb9ff180a9f.png"},705:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/2-mailboxes-6157ee03965392d6f4b082b7fff6f743.png"},9634:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/3-object-lifecycle-9300fe92d788f8091da32f638495b0a2.png"},8828:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/4-actor-lifecycle-ca68ae2be7bf31d45e95162d816321db.png"}}]);